" vim: set tw=0 wm=0 sw=4 ts=4 sts=4 et foldmarker={{{,}}} foldlevel=0 foldmethod=marker nospell:
"
"
"    (                 )           )
"    )(    (    (     /((   (   ( /(
"   (()\   )\   )\ ) (_))\  )\  )\())
"    ((_) ((_) _(_/( _)((_)((_)((_)\
"   | '_|/ _ \| ' \))\ V // _ \\ \ /
"   |_|  \___/|_||_|  \_/ \___//_\_\
"
" Vim Settings {{{

syntax on                           " Syntax highlighting
filetype on
filetype plugin on
set omnifunc=syntaxcomplete#Complete
set numberwidth=6                   " Set the width of the number column
set complete-=i                     " Set the matches for insert mode completion
set equalalways                     " Make all the windows and splits the same size
set t_ti= t_te=                     " config vim to not to restore the screen.
set laststatus=2                    " determines if the last window will have a status line. values: 0:never 1:maybe 2:always
set guioptions=a                    " Autoselect
set guioptions+=c                   " Console dialog instead of popup
set guioptions+=h                   " Limit horizontal scrollbar to cursor line length
set guioptions+=e                   " Add gui tab pages when needed
set guioptions+=g                   " Gray non-active menu items
set guioptions+=i                   " Use the Vim icon
set guioptions-=m                   " remove menu bar
set guioptions-=T                   " remove toolbar
set guioptions-=R                   " remove right-hand scroll bar
set guioptions-=r                   " remove right-hand scroll bar
set guioptions-=L                   " remove left-hand scroll bar
set guioptions-=l                   " remove left-hand scroll bar
set gcr=n-c:block-Cursor-blinkon0   " Different cursor for normal mode
set gcr+=v:block-vCursor-blinkon0   " Different cursor for visual mode
"set gcr+=i-ci:ver20-iCursor         " Different cursor for insert mode
set gcr+=i-ci:hor10-Search          " Different cursor for insert mode
    " i-ci : insert and command-line insert
    " hor10: Horizontal bar, 10% of height
    " Search: Yellow, the background color from the "Search" highlight group.

"highlight Cursor gui=reverse guifg=NONE guibg=NONE
"highlight Cursor gui=NONE guifg=bg guibg=fg

set antialias                       " To improve the font resolution
set shortmess+=I                    " remove the startup message
set shortmess+=afilmnrxoOtT         " Abbrev. of messages (avoids 'hit enter')
                                        " a - terse messages (like [+] instead of [Modified]
                                        " f -
                                        " i -
                                        " l -
                                        " m -
                                        " n -
                                        " r -
                                        " x -
                                        " o -
                                        " O -
                                        " t - truncate file names
                                        " I - no intro message when starting vim fileless
                                        " T - truncate long messages to avoid having to hit a key
set background=dark                 " Assume a dark background
set mouse=a                         " Automatically enable mouse usage
set mousehide                       " Hide the mouse cursor while typing
"set autowrite                      " Automatically write a file when leaving a modified buffer
set virtualedit=onemore             " Allow for cursor beyond last character
set history=10000                   " Store a ton of history (default is 20)
set viminfo+=:100                   " keep lots of stuff
set viminfo+=/100                   " keep lots of stuff
set switchbuf=useopen               " do not duplicate an existing open buffer
set spell                           " Spell checking on
set hidden                          " Set hidden to allow buffers to be browsed
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
set iskeyword-=-                    " '-' is an end of word designator
set backup                          " Backups are nice ...
set tabpagemax=15                   " Only show 15 tabs
set showmode                        " Display the current mode
set cursorline                      " Highlight current line
set linespace=0                     " No extra spaces between rows
set winminheight=0                  " Windows can be 0 line high
set ignorecase                      " Case insensitive search if all lowercase
set smartcase                       " Case sensitive when uppercase present
set wildmenu                        " Show list instead of just completing
set whichwrap=b,s,h,l,<,>,[,],~     " Backspace, Space, Arrow keys, and cursor keys wrap to next/prev line
set scrolljump=5                    " Lines to scroll when cursor leaves screen
set scrolloff=8                     " Minimum lines to keep above and below cursor
set foldenable                      " enable folding an any file
set nowrap                          " Do not wrap long lines
set autoindent                      " Indent at the same level of the previous line
set shiftwidth=2                    " Use indents of 2 spaces
set expandtab                       " Tabs are spaces, not tabs
set tabstop=2                       " An indentation every two columns
set softtabstop=2                   " Let backspace delete indent
filetype indent on
set cindent                         " set autoindent
set nojoinspaces                    " Prevents inserting two spaces after punctuation on a join (J)
set splitright                      " Puts new vsplit windows to the right of the current
set splitbelow                      " Puts new split windows to the bottom of the current
"set matchpairs+=<:>                " Match, to be used with %
"set pastetoggle=<F12>              " pastetoggle (sane indentation on pastes)
"set comments=sl:/*,mb:*,elx:*/     " auto format comment blocks
set synmaxcol=800                   " Don't try to highlight lines longer than 800 characters.
set autoread                        " Make Vim automatically open changed files
set backspace=indent,eol,start      " allow backspacing over everything in insert mode
set clipboard=unnamed               " yank to clipboard
set colorcolumn=80                  " show columns at 80 and 120
set pumheight=8                     " Limit hight of popup menu
set diffopt=filler                  " Options for diff mode
set diffopt+=context:4              " Options for diff mode
set diffopt+=iwhite                 " Options for diff mode
set diffopt+=vertical               " prefer vertical orientation when using :diffsplit
set foldlevelstart=10               " open most folds by default
set foldnestmax=10                  " 10 nested folders max
set gdefault                        " assume the /g flag on :s substitutions to replace all matches
set hlsearch                        " Highlight search results
set incsearch                       " as I start a search, the cursor jumps to the first match
set lazyredraw                      " only redraw when needed
set list                            " Show invisible characters
set modelines=5                     " The number of lines that is checked for set commands
set noautochdir                     " Prevent changing directory when opening files
set noerrorbells                    " Disable error bells
set noesckeys                       " (Hopefully) removes the delay when hitting esc in insert mode
set nospell                         " Disable spell check
set nostartofline                   " Don't reset cursor to start of line when moving around.
set number                          " Show line number
set relativenumber                  " ...but show relative numbers except for the current line
set ruler                           " Show ruler on the statusline
set sidescrolloff=15                " the min.number of screen columns to keep to the left and right of the cursor
set sidescroll=1                    " When to start scrolling
set showcmd                         " Show command line
set showmatch                       " highlight matching [{()}]
set tags=./.tags;,.tags;            " tags files are hidden
set title                           " Vim sets terminal title
set conceallevel=2                  " display unicode chars instead of plaintex known as conceal
set concealcursor=vc                 " Sets the modes in which text in the cursor line can also be concealed.
                                    " n normal mode
                                    " v visual mode
                                    " i insert mode
                                    " c command line editing
set ttimeoutlen=50                  " removes the delay when hitting esc in insert mode
set ttyfast                         " sends more characters to the screen for fast terminal connections
set wildmode=longest,list:full      " Command <Tab> complete to longest match, then list posible matches
set showtabline=2                   " Always show tab line
set guitablabel=%m%N:%t[%{tabpagewinnr(v:lnum)}] " Set up tab labels
set tabline=%!MyTabLine()           " Set up tab labels
set guitabtooltip=%F                " Set up tab tooltips with each buffer name
set matchtime=1                     " Decrease the time to blink
set textwidth=0 wrapmargin=0        " turn off hard line wrapping
set formatoptions+=rnlmM            " Optimize format options :set formatoptions+=rnlmM
                                      " t: autowrap text using textwidth
                                      " c: autowrap comments using textwidth
                                      " r: autoinsert comment leader with <enter>
                                      " q: allow formatting of comments with gq
                                      " l: long lines are not broken in insert mode: When a line was longer than 'textwidth' when the insert command started, Vim does not automatically format it.
                                      " 1: don't break a line after a one-letter word. It's broken before it instead (if possible).
                                      " j: where it makes sense, remove a comment leader when joining lines
                                      " a: automatic formatting of paragraphs
                                      " w: trailing white space indicates a paragraph continues in the next line
                                      " o: insert comment leader after o or O
                                      " n, m, M ?
set linebreak                       " Wrap long lines at a blank rather than at the last char that fits
set fillchars+=diff:⣿,vert:│        " Change fillchars
highlight VertSplit ctermbg=NONE guibg=NONE
set magic                           " Turn magic on for regexp
set fileformats=unix,dos,mac        " Standard file type
set visualbell t_vb=                " no flash screen for the visual bell
if has('autocmd')
  autocmd GUIEnter * set visualbell t_vb=
endif
set showbreak=↳\ \ \                " character to show in the break line
set rop=type:directx,gamma:1.0,contrast:0.5,level:1,geom:1,renmode:4,taamode:1
set wildignore+=*.7z,*.a,*.bmp,*.class,*.com,*.d,*.dll,*.dmg,*.dump,*.egg,*.exe,*.gcda,*.gcno,*.gem,*.gif,*.gz,*.hg,*.ico,*.iso,*.jar
set wildignore+=*.jpeg,*.jpg,*.la,*.log,*.mo,*.o,*.obj,*.png,*.pyc,*.rar,*.so,*.sql,*.sqlite,*.svn,*.swf,*.swp,*.tar,*.tar.bz2,*.tar.gz,*.tgz
set wildignore+=*.tmp,*.xpm,*.zip,.DS_Store,.DS_Store?,.Spotlight-V100,.Trashes,._*,.env,Homestaad.json,Homestead.yaml,Thumbs.db,bower_components,ehthumbs.db,node_modules
set wildignore+=*/__pycache__
set wildignore+=*/node_modules
set wildignore+=*/tmp/*
set wildignore+=*~
set wildignore+=/node_modules
set wildignore+=/vendor
set noswapfile
set nobackup
set nowritebackup
set titlestring=%t%(\ %m%)%(\ (%{expand('%:p:h')})%)%(\ %a%)"
set completeopt=longest,menuone,preview " complete menu visibility
set listchars=tab:▸\ ,eol:¬,trail:•,extends:❯,precedes:❮,nbsp:. " Highlight problematic whitespace
set printoptions=number:y,duplex:off,paper:letter,left:5pc,right:5pc,top:5pc,bottom:5pc     " Set the printer options
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$' " Highlight VCS conflict markers
set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
""for windows
"set guifont=RobotoMono_Nerd_Font_Light:h11:cANSI:qDRAFT
"set guifont=RobotoMono_Nerd_Font_Light:h11
"set guifont=Inconsolata-dz_for_Powerline:h11:cANSI:qDRAFT
"set guifont=Inconsolata-dz_for_Powerline:h11
"set guifont=Droid_Sans_Mono_Slashed_for_Pow:h11:cANSI:qDRAFT
"set guifont=Droid_Sans_Mono_Slashed_for_Pow:h11
"set background=dark
"set noantialias     " Turn on/off anti-aliased fonts
set encoding=utf-8

" Vim Settings }}}

" Lets {{{
let g:solarized_hitrail=1

let g:gundo_width = 60
let g:gundo_preview_height = 40
let g:gundo_right = 0
let g:gundo_preview_botton = 1

let g:ackprg = 'ag --vimgrep' "silversearch-ag, with report every match on the line
" Use ag, searcher, for ctrlp search.
" Note: wildignore doesn't apply with this option, you need .agignore file
let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
"---------- ag search
let g:ag_working_path_mode="r" " Search in project directory
"---------- ag search

" Enables syntax highlighting for JSDocs.
let g:javascript_plugin_jsdoc = 1
" Enables some additional syntax highlighting for NGDocs. Requires JSDoc plugin to be enabled as well.
let g:javascript_plugin_ngdoc = 1
" Enables syntax highlighting for Flow.
let g:javascript_plugin_flow = 1
" Customize Concealing Characters
let g:javascript_conceal_function             = "ƒ"
let g:javascript_conceal_null                 = "ø"
let g:javascript_conceal_this                 = "@"
let g:javascript_conceal_return               = "⇚"
let g:javascript_conceal_undefined            = "¿"
let g:javascript_conceal_NaN                  = "ℕ"
let g:javascript_conceal_prototype            = "¶"
let g:javascript_conceal_static               = "•"
let g:javascript_conceal_super                = "Ω"
let g:javascript_conceal_arrow_function       = "⇒"

"augroup ProjectDrawer
"  autocmd!
"  autocmd VimEnter * :Ex
"augroup END

" Multiple_cursors settings
let g:multi_cursor_use_default_mapping=0
" Default mapping
let g:multi_cursor_start_word_key      = '<C-n>'
let g:multi_cursor_select_all_word_key = '<C-A-n>'
let g:multi_cursor_start_key           = 'g<C-n>'
let g:multi_cursor_select_all_key      = 'g<A-n>'
let g:multi_cursor_next_key            = '<C-n>'
let g:multi_cursor_prev_key            = '<C-p>'
let g:multi_cursor_skip_key            = '<C-x>'
let g:multi_cursor_quit_key            = '<Esc>'
" Default highlighting (see help :highlight and help :highlight-link)
highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual

" GITGUTTER "
"""""""""""""
let g:gitgutter_max_signs = 1000

" Lets }}}

" Conditionals {{{

if executable("ag")
    "let g:CtrlSpaceGlobCommand = 'ag -l --nocolor -g ""'
    let g:CtrlSpaceGlobCommand = 'ag -l --hidden -g ""'
endif

" allows cursor change in tmux mode
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

if !has('gui')
    set term=$TERM          " Make arrow and other keys work
endif

if has('clipboard')
    if has('unnamedplus')  " When possible use + register for copy-paste
        set clipboard=unnamed,unnamedplus
    else         " On mac and Windows, use * register for copy-paste
        set clipboard=unnamed
    endif
endif

"Color column 80 and everything after
if exists('+colorcolumn')
    set colorcolumn=80 " show columns at 80 and 120
endif

" Conditionals }}}

" Autocmds {{{

"autocmd FileType vim set foldmethod=marker

" Only have cursorline in current window and in normal window
autocmd WinLeave * set nocursorline nocursorcolumn
autocmd WinEnter * set cursorline cursorcolumn
autocmd InsertEnter * set nocursorline nocursorcolumn
autocmd InsertLeave * set cursorline cursorcolumn

" Always show the sign (also called gutter) {
autocmd BufEnter * sign define dummy
autocmd BufEnter * execute 'sign place 9999 line=1 name=dummy buffer=' . bufnr('')

"autocmd FocusLost * :silent! wall

autocmd BufNewFile,BufRead *.html setlocal commentstring=<!--%s-->
" ruby commenstring
autocmd FileType ruby setlocal commentstring=#%s
" make help navigation easier
autocmd FileType help nnoremap <buffer> <CR> <C-]>
autocmd FileType help nnoremap <buffer> <BS> <C-T>

au FileType c,h,java,js setlocal mps+==:;                   " allow the match pairs operation (%) to work with '=' and ';'

" Autocmds }}}

" Commands {{{

" Alphabetically sort CSS properties in file with :SortCSS
:command! SortCSS :g#\({\n\)\@<=#.,/}/sort
" Sort CSS properties alphabetically when inside css block {}
map <leader><leader>s ?{<CR>jV/^\s*\}\=$<CR>k:sort<CR>:let @/=''<CR>

" git add -A . && git commit with message all in command line
command! -nargs=1 GitCommitQuick call GitCommitQuick(<f-args>)
" FillUp the quicklist
command! -nargs=1 Ss let @/ = <q-args>|set hlsearch
" Find the middle of the current line
command! MOTCL :call cursor(0, virtcol('$')/2)
" Find longest line in the file
command! PPLL :call PrependLongestLineLength()
" what to do with diff runing, use ,do to start comparing the cur.file with
" the original version, and use ,dc to exit.
command! DiffOrig let g:diffline = line('.') | vert new | set bt=nofile | r # | 0d_ | diffthis | :exe "norm! ".g:diffline."G" | wincmd p | diffthis | wincmd p
" Search without escaping slash
command! -nargs=1 Ss let @/ = <q-args>|set hlsearch
"---------- Silently execute external commands, without needing to redraw
command! -nargs=1 Silent
            \ | execute ':silent !'.<q-args>
            \ | execute ':redraw!'
" Reverse a list of items in a range. Ex. :10,20Reverse or use tac in linux Ex. :'<,'>!tac
command! -bar -range=% Reverse <line1>,<line2>global/^/m<line1>-1

" Commands }}}

" HighLights {{{

" I ♥ colors,
" change colors for the popup menu
highlight Pmenu NONE
highlight Pmenu guibg = #112125
highlight Pmenu ctermbg = 195 ctermfg = 000 cterm = standout
highlight PmenuSel guifg = #004a5d guibg = #FFFFFF

highlight clear SignColumn      " SignColumn should match background
highlight clear LineNr          " Current line number row will have same background color in relative mode

"highlight clear CursorLineNr    " Remove highlight color from current line number
"highlight clear LineNrlet

" fix conceal color
highlight Conceal guifg = yellow guibg = #002b36 gui = bold
"highlight Conceal ctermbg = NONE ctermfg = NONE guibg = NONE guifg = NONE

"highlight ExtraWhitespace
highlight link ExtraWhitespace SpellCap
highlight ExtraWhitespace guibg = #073642 guifg = #dc322f gui = undercurl ctermbg = NONE ctermfg = 237 cterm = undercurl

" Default matching parent highlight is too visible, this is a more discrete highlight.
highlight MatchParen guibg = white guifg = NONE gui = reverse ctermbg = black ctermfg = white cterm = reverse
highlight SpellBad term = underline gui = undercurl guisp = Orange

" HighLights }}}

" Mappings {{{

" Automatically call Tabular to align on | for Cucumber tables.
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a

" In Normal Mode we press D to del all from cursor to end of line. Use Ctrl-D to do the same in Insert Mode.
inoremap <C-Del> <C-\><C-o>D

" Jumping git hunks with vim-gitgutter
nmap ]c <Plug>GitGutterNextHunk
nmap [c <Plug>GitGutterPrevHunk

" Find merge conflict markers, similar to errors in Git
"map <leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" toggle background dark/white
noremap <leader>bg :call ToggleBG()<CR>

" Wrapped lines goes down/up to next row, rather than next line in file.
noremap j gj
noremap k gk

" It jumps to the next row in the editor
nnoremap j gj
nnoremap k gk

" it's 2012. move up/down to the character immediately above/below the current one
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" exit insert mode fast with jk
inoremap jk <ESC>

" Keep the cursor in place while joining lines
nnoremap J mzJ`z

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" Code folding options
nmap <leader>f0 :set foldlevel=0<CR>
nmap <leader>f1 :set foldlevel=1<CR>
nmap <leader>f2 :set foldlevel=2<CR>
nmap <leader>f3 :set foldlevel=3<CR>
nmap <leader>f4 :set foldlevel=4<CR>
nmap <leader>f5 :set foldlevel=5<CR>
nmap <leader>f6 :set foldlevel=6<CR>
nmap <leader>f7 :set foldlevel=7<CR>
nmap <leader>f8 :set foldlevel=8<CR>
nmap <leader>f9 :set foldlevel=9<CR>

" Change Working Directory to that of the current file
cmap cwd lcd %:p:h
cmap cd. lcd %:p:h

" switch path of cwd to current open buffer
map <leader>cd :cd %:p:h<cr>:pwd<cr>

" Visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv

" Allow using the repeat operator with a visual selection (!)
" http://stackoverflow.com/a/8064607/127816
vnoremap . :normal .<CR>

" For when you forget to sudo.. Really Write the file.
" use w!! to write protected files
"cmap w!! w !sudo tee % >/dev/null
cmap w!! %!sudo tee > /dev/null %
" cmap W!! w !sudo tee % >/dev/null   " I can not understand
" Save a file with sudo
cnoremap w!! %!sudo tee > /dev/null %
"cnoremap w!! w !sudo tee % >/dev/null
"command! Sudo exec 'w !sudo tee % > /dev/null' | e!
command! Sudo :execute ':silent w !sudo tee % > /dev/null' | :edit!

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

" Adjust viewports to the same size
map <Leader>= <C-w>=

" Map <Leader>ff to display all lines with keyword under cursor
" and ask which one to jump to
nmap <Leader>ff [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>

" Easier horizontal scrolling
map zl zL
map zh zH

" Easier formatting
nnoremap <silent> <leader>q gwip

" Populates the quicklist with the proper files when using with vimgrep
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()

" -----------------SEARCHING begin
" Search/Replace for text under visual selection, we can add gic
vnoremap <leader>s y:%s/<C-R>0//gic<Left><Left><Left><Left>

" Search/Replace for text
nnoremap <Leader>s :%s/\<<C-r><C-w>\>//gic<Left><Left><Left><Left>

" Search current visual selection
vnoremap // y/<C-R>"<CR>

" Search with ag, the silver searcher
nnoremap <leader>f :Ag<space>

" Search yanked text with the silver searcher
nnoremap <leader>F :Ag '<C-r>0'<CR>

" Search visual selction with ag
vmap <leader>f y:Ag<space><C-R>0<space>-i
"vnoremap <leader>f y:Ag '<C-r>0'<CR>

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>? :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>
" Ack for the last search.
nnoremap <silent> <leader>/ :execute "Ack! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>

" When you press gv you vimgrep after the selected text project wide
vnoremap <silent> gv :call VisualSelection('gv')<CR>

" Open vimgrep and put the cursor in the right position, project wide
map <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>

" Vimgreps in the current file
map <leader><space> :vimgrep // <C-R>%<C-A><right><right><right><right><right><right><right><right><right>

" show last search results on the quickfix window at windows bottom
map <leader>co :botright copen<cr>

" Copy the whole file and pasted in a new buffer
"map <leader>fc ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
map <leader>fc ggVGy:vnew<cr>:set syntax=qf<cr>pgg
" -----------------SEARCHING end

" yank current buffer's filepath
nnoremap \f :call setreg(v:register, substitute(expand('%:p'),'\','/','g'))<CR>

" Indent pastes properly
nnoremap <leader>pi p`[v`]=

" swapping. swap current paragraph with next
nnoremap g{ {dap}p{

" delete and swap text. first delete some text and then swap the visual selection with Ctrl-X
" to use it: delete some text using daw or dt? or x, then use visual mode to
" select other text and press Ctrl-X. The two pieces of text will be swapped.
vnoremap <C-X> <Esc>`.``gvP``P

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" Easy window navigation
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

" Krack line under cursor (insert a line break)
nnoremap K i<CR><Esc>

" Disable arrows and mouse wheel in insert mode
inoremap <silent> <ESC>OA <Nop>
inoremap <silent> <ESC>OB <Nop>
inoremap <silent> <ESC>OC <Nop>
inoremap <silent> <ESC>OD <Nop>

" cltrp command palette
"nnoremap <leader>; :CtrlPCmdPalette<CR>
nnoremap <leader>; :CtrlPMRU<CR>
nnoremap <leader>o :CtrlPBuffer<CR>

" Reindent all and return the same line where you were
nnoremap <leader>af :Autoformat<CR>
vnoremap <leader>af :'<,'>Autoformat<CR>

" reset the iminsert to 0 when leaving insert mode with ESC
inoremap <ESC> <ESC>:set iminsert=0<CR>

" Toggle capslock plugin in insert mode
imap <A-l> <Plug>CapsLockToggle
nmap <leader>l <Plug>CapsLockToggle

" toggle caps on/off
nnoremap gC I/* A */

" Arrow keys disable
map <Left>  <Nop>
map <Right> <Nop>
map <Up>    <Nop>
map <Down>  <Nop>

" Toggle between number and relativenumber
nnoremap <leader>rl :call ToggleNumber()<CR>

" Programming Functions
"   <F2=navigateMarks>
"   <F3=toggleSpell>
"   <F5=delTrailingspace>
"   <F7=reformatFile>
"   <F9=insertDate>
"
"   <F4=available>
"   <F6=available>
"   <F8=available>
"   <F11=available>

" <F2> Navigate marks with F2, like in ST
"nnoremap <silent> <F2> :AirlineRefresh<CR>
nmap <F2> <Esc>]`

" <F3> toggle spell on/off
noremap <F3> :set spell!<CR>

" <F4> available
"noremap <F4> :A<CR>
" Strip all trailing whitespace in the current file
"nnoremap <Leader>q :%s/\s\+$//<CR>:let @/=''<CR>

" <F5> Remove the trailing whitespace
nnoremap <silent> <F5> :call StripTrailingWhitespace()<CR>

" <F6> Show buffers and ask to select one
"nnoremap <F6> :buffers<CR>:buffer<Space>

" <F7> Will reformat and reindent the whole file
map <F7> mzgg=G`z<esc>ggVG=`z<esc>

" <F8> Switch all buffers into tabs or vice versa
"let notabs = 1
"nnoremap <silent> <F8> :let notabs=!notabs<Bar>:if notabs<Bar>:tabo<Bar>:else<Bar>:tab ball<Bar>:tabn<Bar>:endif<CR>

" <F9> applies a rot13 dmca-grade encryption scheme to your file
"nnoremap <F9> mzggg?G`z
"nnoremap <F9> mzggVGg?`z
"map <F9> mzggg?G`z  "(seems to be faster than mzggVGg?`z)
nnoremap <F9> m'A<C-R>="\t".strftime('%Y-%m-%dT%H_%M_%S')<CR><Esc>``

" fullscreen mode for GVIM and Terminal, need 'wmctrl' in you PATH
"map <silent> <F11> :call system("wmctrl -ir " . v:windowid . " -b toggle,fullscreen")<CR>

" Modify all the indents
nnoremap \= gg=G

" Close buffers
map <leader>bd :bd!<CR>     " Close current buffer
map <leader>ba :%bd<CR>     " Close all buffers

" turn off search highlight and close quickfix
"nnoremap <silent> <leader><leader> :nohlsearch \| ccl \| lclose \| SignifyRefresh \| redraw!<CR>
" remove all highlights
map <silent> <leader><cr> :noh<cr>

" quick save
nmap <leader>w :w!<cr>

" return to the last editing file
map ** "zyy:@z<Enter>
map ; :e#<Enter>

" same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" SOMETHING SIMILAR: MOVE TO LAST CHANGE
nnoremap gI `.

" Fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" keep current line in the center of the screen mode
nnoremap <leader>C :let &scrolloff=999-&scrolloff<cr>

" easier to type, and i never use the default behavior.
noremap H ^
noremap L $
vnoremap L g_

" Heresy
inoremap <c-a> <esc>I
inoremap II <Esc>I
inoremap ii <Esc>I

" go to eol in insertmode and keep inserting
inoremap <c-e> <esc>A
inoremap AA <Esc>A
inoremap aa <Esc>A

" delete curr line, end in normalmode
inoremap DD <Esc>dd

" in visualmode * or # search for cur-selection
vnoremap <silent> * :call VisualSelection('f')<CR>
vnoremap <silent> # :call VisualSelection('b')<CR>
nnoremap <C-Left> :tabprevious<CR>
nnoremap <C-Right> :tabnext<CR>
nnoremap <silent> <A-Left> :execute 'silent! tabmove ' . (tabpagenr()-2)<CR>
nnoremap <silent> <A-Right> :execute 'silent! tabmove ' . tabpagenr()<CR>

" ,do open ori.ver of the file in a split to compare, and ,dc closes
nnoremap <Leader>do :DiffOrig<cr>
nnoremap <leader>dc :q<cr>:diffoff<cr>:exe "norm! ".g:diffline."G"<cr>

" execute :diffoff
nnoremap <leader>D :diffoff!<cr>

" move line up/down in normal, insert or visual modes
nnoremap <A-j> :m .+1<CR>==
nnoremap <A-k> :m .-2<CR>==
inoremap <A-j> <Esc>:m .+1<CR>==gi
inoremap <A-k> <Esc>:m .-2<CR>==gi
vnoremap <A-j> :m '>+1<CR>gv=gv
vnoremap <A-k> :m '<-2<CR>gv=gv

" makes easy to type regex
noremap ;; :%s:::g<Left><Left><Left>
noremap ;' :%s:::cg<Left><Left><Left><Left>
cmap ;\ \(\)<Left><Left>

" Repeat last substitution, including flags, with &.
nnoremap & :&&<CR>
xnoremap & :&&<CR>

" Select entire buffer
nnoremap vaa gg0vGg_

" HTML tag closing
inoremap <C-_> <Space><BS><Esc>:call InsertCloseTag()<cr>a

" Cmdheight switching
nnoremap <leader>1 :set cmdheight=1<cr>
nnoremap <leader>2 :set cmdheight=2<cr>

" copy to system buffer
vnoremap <C-S-C> "+y<CR>
map <C-S-c>  "+y<CR>

" Close buffers without pain
"nnoremap <silent> <leader>x :bd<CR>
"nnoremap ; :   "removed

" Refocus folds
nnoremap ,z zMzvzz

" Save without pain
nnoremap <silent> <leader>w :w<CR>
nnoremap <silent> z<space> :w<CR>

" turn off search highlight and close quickfix
nnoremap <silent> <leader><leader> :nohlsearch \| ccl \| lclose \| SignifyRefresh \| redraw!<CR>

" git add -A . && git commit with message all in command line
nnoremap <leader>gg :GitCommitQuick<space>
nnoremap <leader>gps :silent Dispatch! gps<CR>
nnoremap <leader>gpl :silent Dispatch! gpl<CR>
nnoremap <leader>gd :!gd<CR><CR>
nnoremap <leader>gl :!gl<CR><CR>

" Automatically jump to end of text you pasted: paste multiple with pppp
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" Junp buffers left or right
nnoremap <silent> <LEFT>  :bprevious<CR>
nnoremap <silent> <RIGHT> :bnext<CR>

" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

" Mappings }}}

" Plugins Settings {{{

" Lightline {{{

" vim-gitgutter
let g:gitgutter_sign_added = '✚'
let g:gitgutter_sign_modified = '➜'
let g:gitgutter_sign_removed = '✘'

highlight User1 guifg = #eee8d5 guibg = #073642 ctermfg = white ctermbg = NONE
highlight User2 guifg = #ffffff guibg = #dc322f ctermfg = white ctermbg = red
highlight User3 guifg = yellow guibg = #112125 ctermfg = yellow ctermbg = black gui=bold cterm=bold
highlight Conceal ctermbg = NONE ctermfg = NONE guibg = NONE guifg = NONE

" lightline.vim
let g:lightline = {
        \ 'colorscheme': 'lightline_solarized_dark',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [
        \     ['mode', 'paste'],
        \     ['fugitive', 'gitgutter'],
        \     ['ronvoxreadonly', 'filename', 'ronvoxname', 'modified'],
        \     ['filetype', 'ctrlpmark']
        \   ],
        \   'right': [
        \     ['lineinfo', 'syntastic'],
        \     ['percent'],
        \     ['charcode', 'charvalue', 'fileformat', 'fileencoding']
        \   ]
        \ },
        \ 'component': {
        \   'lineinfo':         ' %4l:%-3v %L',
        \   'charvalue':        '%05.5b',
        \   'charvaluehex':     '#x%04B',
        \   'ronvoxreadonly':   '%2*%{&readonly?"  ":""}%1*',
        \   'modified':         '%2*%m%1*',
        \   'ronvoxname':       '%3* %t %1*',
        \ },
        \ 'component_function': {
        \   'fugitive':     'LightlineFugitive',
        \   'filename':     'LightlineFilename',
        \   'fileformat':   'MyFileformat',
        \   'filetype':     'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'mode':         'LightlineMode',
        \   'charcode':     'MyCharCode',
        \   'gitgutter':    'MyGitGutter',
        \   'ctrlpmark':    'CtrlPMark',
        \ },
        \ 'component_expand': {
        \   'syntastic': 'SyntasticStatuslineFlag',
        \ },
        \ 'component_type': {
        \   'syntastic': 'error',
        \ },
        \ 'separator': { 'left': '', 'right': '' },
        \ 'subseparator': { 'left': '', 'right': '|' }
        \ }

"function! LightlineModified()
"  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
"endfunction

"function! LightlineReadonly()
"  return &ft !~? 'help' && &readonly ? '' : ''
"endfunction

function! LightlineFilename()
  let fname = expand('%:p:h')
  return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != CapsLockStatusline() ? ' ' . CapsLockStatusline() : '')
endfunction

function! LightlineMode()
  let fname = expand('%:p:h')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! LightlineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD\vimfiler\|gundo' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ' '  " edit here for cool mark
      let branch = fugitive#head()
      return branch !=# '' ? mark.branch : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
        \ || ! get(g:, 'gitgutter_enabled', 0)
        \ || winwidth('.') <= 90
    return ''
  endif
  let symbols = [
        \ g:gitgutter_sign_added . ' ',
        \ g:gitgutter_sign_modified . ' ',
        \ g:gitgutter_sign_removed . ' '
        \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return join(ret, ' ')
endfunction

" https://github.com/Lokaltog/vim-powerline/blob/develop/autoload/Powerline/Functions.vim
function! MyCharCode()
  if winwidth('.') <= 70
    return ''
  endif

  " Get the output of :ascii
  redir => ascii
  silent! ascii
  redir END

  if match(ascii, 'NUL') != -1
    return 'NUL'
  endif

  " Zero pad hex values
  let nrformat = '0x%02x'

  let encoding = (&fenc == '' ? &enc : &fenc)

  if encoding == 'utf-8'
    " Zero pad with 4 zeroes in unicode files
    let nrformat = '0x%04x'
  endif

  " Get the character and the numeric value from the return value of :ascii
  " This matches the two first pieces of the return value, e.g.
  " "<F>  70" => char: 'F', nr: '70'
  let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

  " Format the numeric value
  let nr = printf(nrformat, nr)

  return "'". char ."' ". nr
endfunction


function! CtrlPMark()
  if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

""""""" solarized colours
" #004a5d
" #112125
" #002b36 //Base03
" #073642 //Base02
" #586e75 //Base01
" #657b83 //Base00
" #839496 //Base0
" #93a1a1 //Base1
" #eee8d5 //Base2
" #fdf6e3 //Base3
"
" #b58900 //yellow
" #cb4b16 //orange
" #dc322f //red
" #d33682 //magenta
" #6c71c4 //violet
" #268bd2 //blue
" #2aa198 //cyan
" #859900 //green

" Lightline }}}

" NERDTree {{{

" Remove the dots after icons in NERDTree, the dicons just shows half
"autocmd FileType nerdtree setlocal nolist

" 'suffixes' get ignored by tmru
set suffixes+=.7z
set suffixes+=.a
set suffixes+=.bmp
set suffixes+=.class
set suffixes+=.com
set suffixes+=.d
set suffixes+=.dll
set suffixes+=.dmg
set suffixes+=.dump
set suffixes+=.egg
set suffixes+=.exe
set suffixes+=.gcda
set suffixes+=.gcno
set suffixes+=.gem
set suffixes+=.gif
set suffixes+=.gz
set suffixes+=.hg
set suffixes+=.ico
set suffixes+=.iso
set suffixes+=.jar
set suffixes+=.jpeg
set suffixes+=.jpg
set suffixes+=.la
set suffixes+=.log
set suffixes+=.mo
set suffixes+=.o
set suffixes+=.obj
set suffixes+=.png
set suffixes+=.pyc
set suffixes+=.rar
set suffixes+=.so
set suffixes+=.sql
set suffixes+=.sqlite
set suffixes+=.svn
set suffixes+=.swf
set suffixes+=.swp
set suffixes+=.tar
set suffixes+=.tar.bz2
set suffixes+=.tar.gz
set suffixes+=.tgz
set suffixes+=.tmp
set suffixes+=.xpm
set suffixes+=.zip

set suffixes+=.DS_Store
set suffixes+=.DS_Store?
set suffixes+=.Spotlight-V100
set suffixes+=.Trashes
set suffixes+=._*
set suffixes+=.env

set suffixes+=Homestaad.json
set suffixes+=Homestead.yaml
set suffixes+=Thumbs.db
set suffixes+=bower_components
set suffixes+=ehthumbs.db
set suffixes+=node_modules

let NERDTreeIgnore = []
"for suffix in split(&suffixes, ',')
"    let NERDTreeIgnore += [ escape(suffix, '.~') . '$' ]
"endfor

let NERDTreeIgnore += ['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
let NERDTreeIgnore += ['^\.bundle$', '^\.bzr$', '^\.sass-cache$', '^\.$', '^\.\.$', '^Thumbs\.db$']
let NERDTreeIgnore += ['__pycache__', '.ropeproject']
let NERDTreeIgnore += ['\.7z$', '\.a$', '\.bmp$', '\.class$', '\.com$', '\.d$', '\.dll$', '\.dmg$', '\.dump$', '\.egg$', '\.exe$', '\.gcda$']
let NERDTreeIgnore += ['\.gcno$', '\.gem$', '\.gif$', '\.gz$', '\.ico$', '\.iso$', '\.jar$', '\.jpeg$', '\.jpg$', '\.la$', '\.log$']
let NERDTreeIgnore += ['\.mo$', '\.o$', '\.obj$', '\.png$', '\.pyc$', '\.rar$', '\.so$', '\.sql$', '\.sqlite$', '\.swf$']
let NERDTreeIgnore += ['\.tar$', '\.tar.bz2$', '\.tar.gz$', '\.tgz$', '\.tmp$', '\.xpm$', '\.zip$', '\.DS_Store$', '\.DS_Store?$']
let NERDTreeIgnore += ['\.Spotlight-V100$', '\.Trashes$', '\._*$', '\.env$', 'Homestaad\.json$', 'Homestead\.yaml$', 'bower_components$', 'ehthumbs\.db$', 'node_modules$']

" NERDTress File highlighting
function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
  exec 'autocmd FileType nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
  exec 'autocmd FileType nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
endfunction

call NERDTreeHighlightFile('jade', 'green', 'none', 'green', '#002b36')
call NERDTreeHighlightFile('text', 'green', 'none', 'green', '#002b36')
call NERDTreeHighlightFile('txt', 'green', 'none', 'green', '#002b36')
call NERDTreeHighlightFile('vim', 'green', 'none', 'green', '#002b36')
call NERDTreeHighlightFile('ini', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('md', 'blue', 'none', '#3366FF', '#002b36')
call NERDTreeHighlightFile('yml', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('config', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('conf', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('json', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('html', 'yellow', 'none', 'yellow', '#002b36')
call NERDTreeHighlightFile('styl', 'cyan', 'none', 'cyan', '#002b36')
call NERDTreeHighlightFile('css', 'cyan', 'none', 'cyan', '#002b36')
call NERDTreeHighlightFile('coffee', 'Red', 'none', 'red', '#002b36')
call NERDTreeHighlightFile('js', 'Red', 'none', '#ffa500', '#002b36')
call NERDTreeHighlightFile('sh', 'white', 'none', '#ffa500', '#002b36')
call NERDTreeHighlightFile('php', 'Magenta', 'none', '#ff00ff', '#002b36')
call NERDTreeHighlightFile('ds_store', 'Gray', 'none', '#686868', '#002b36')
call NERDTreeHighlightFile('gitconfig', 'Gray', 'none', '#686868', '#002b36')
call NERDTreeHighlightFile('gitignore', 'Gray', 'none', '#686868', '#002b36')
call NERDTreeHighlightFile('bashrc', 'Gray', 'none', '#686868', '#002b36')
call NERDTreeHighlightFile('profile', 'Gray', 'none', '#686868', '#002b36')
call NERDTreeHighlightFile('bashprofile', 'Gray', 'none', '#686868', '#002b36')


" Plugin: NERDTree icons and highlights
" ---------------------------------------------------------
let g:NERDTreeIndicatorMapCustom = {
    \ 'Modified':  '·',
    \ 'Staged':    '‧',
    \ 'Untracked': '?',
    \ 'Renamed':   '≫',
    \ 'Unmerged':  '≠',
    \ 'Deleted':   '✃',
    \ 'Dirty':     '⁖',
    \ 'Clean':     '✓',
    \ 'Ignored':   '☒',
    \ 'Unknown':   '⁇'
    \ }

let g:NERDTreeGitStatusIndicatorMap = {
    \ "Modified"  : "✹",
    \ "Staged"    : "✚",
    \ "Untracked" : "✭",
    \ "Renamed"   : "➜",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "✗",
    \ "Clean"     : "✔︎",
    \ 'Ignored'   : '☒',
    \ "Unknown"   : "?"
    \ }

let g:NERDTreeDirArrowExpandable = '▷'
let g:NERDTreeDirArrowCollapsible = '▼'

highlight! NERDTreeOpenable ctermfg=132 guifg=#B05E87
highlight! def link NERDTreeClosable NERDTreeOpenable

highlight! NERDTreeFile ctermfg=246 guifg=#999999
highlight! NERDTreeExecFile ctermfg=246 guifg=#999999

highlight! clear NERDTreeFlags
highlight! NERDTreeFlags ctermfg=234 guifg=#1d1f21
highlight! NERDTreeCWD ctermfg=240 guifg=#777777

highlight! NERDTreeGitStatusModified ctermfg=1 guifg=#D370A3
highlight! NERDTreeGitStatusStaged ctermfg=10 guifg=#A3D572
highlight! NERDTreeGitStatusUntracked ctermfg=12 guifg=#98CBFE
highlight! def link NERDTreeGitStatusRenamed Title
highlight! def link NERDTreeGitStatusUnmerged Label
highlight! def link NERDTreeGitStatusDirDirty Constant
highlight! def link NERDTreeGitStatusDirClean DiffAdd
highlight! def link NERDTreeGitStatusUnknown Comment

function! s:NERDTreeHighlight()
    for l:name in keys(g:NERDTreeIndicatorMapCustom)
        let l:icon = g:NERDTreeIndicatorMapCustom[l:name]
        if empty(l:icon)
            continue
        endif
        let l:prefix = index(['Dirty', 'Clean'], l:name) > -1 ? 'Dir' : ''
        let l:hiname = escape('NERDTreeGitStatus'.l:prefix.l:name, '~')
        execute 'syntax match '.l:hiname.' #'.l:icon.'# containedin=NERDTreeFlags'
    endfor

    syntax match hideBracketsInNerdTree "\]" contained conceal containedin=NERDTreeFlags
    syntax match hideBracketsInNerdTree "\[" contained conceal containedin=NERDTreeFlags
    " setlocal conceallevel=2
    " setlocal concealcursor=nvic
endfunction

augroup nerdtree-highlights
    autocmd!
    autocmd FileType nerdtree call s:NERDTreeHighlight()
augroup END

" Plugin: NERDTree icons and highlights




""let g:NERDTreeUseSimpleIndicator = 0
let g:nerdtree_tabs_open_on_gui_startup=1
let g:nerdtree_tabs_open_on_console_startup=1
let g:NERDTreeGitStatusNodeColorization = 1
let g:netrw_browse_split=0      " open files in previous window
let g:netrw_liststyle=3         " thin (change to 3 for tree)
let g:netrw_banner=0            " no banner
let g:netrw_altv=1              " open files on right
let g:netrw_preview=1           " open previews vertically
let g:netrw_winsize = 35

" NERDTree }}}

" CtrlSpace {{{

"let g:CtrlSpaceFileEngine = "file_engine_windows_386"
let g:CtrlSpaceFileEngine = "file_engine_windows_amd64"
let g:CtrlSpaceDefaultMappingKey = "<tab>"
"let g:airline_exclude_preview = 1

" good config for CtrlSpace symbols using Inconsolata
"if has("gui_running")
"    let g:CtrlSpaceSymbols = { "File": "◯", "CTab": "▣", "Tabs": "▢" }
"endif

"another important settings is the GlobCommand. This cmd is used to collect
"all files in your project directory. We recommend install ag, as it srespects
".gitignore rules and is really fast. Once installed you can add this line.
"let g:CtrlSpaceGlobCommand = 'ag -l --hidden -g ""'
let g:CtrlSpaceGlobCommand = 'ag -l --nocolor -g ""'

"if you deal with huge projects having 100000 files you can increse search delay
let g:CtrlSpaceSearchTiming = 500

"you can adjust some plugin colors. By default plugin uses the following setup:
highlight link CtrlSpaceNormal Pmenu
highlight link CtrlSpaceSelected PmenuSel
highlight link CtrlSpaceSearch Search
highlight link CtrlSpaceStatus StatusLine
highlight link CtrlSpaceFound  Search

"however some color schemes show search results with the same colors as
"PMenu groups. If that's your case try to link CtrlSpaceSearch highlight
"group to IncSearch instead
hi link CtrlSpaceSearch IncSearch

"nothing prevents you from providing your own highlighting, for example:
hi CtrlSpaceSearch guifg=#cb4b16 guibg=NONE gui=bold
                     \ ctermfg=9 ctermbg=NONE term=bold cterm=bold

" CtrlSpace }}}

" Plugins Settings }}}

" vimrc.local Functions {{{

" :Multiple_cursors {{{
" prevent conflict with Neocomfplete
function! Multiple_cursors_before()
if exists(':NeoCompleteLock')==2
  exe 'NeoCompleteLock'
endif
endfunction

function! Multiple_cursors_after()
if exists(':NeoCompleteUnlock')==2
  exe 'NeoCompleteUnlock'
endif
endfunction

" :Multiple_cursors }}}

" :CopyNonFolded {{{
"
"yank/copy only non-folded text or in other words fold titles, and open a new buffer.
"select a range and call CopyFolds cmd or just exec the cmd.
function! CopyNonFolded() range
let lnum= a:firstline
let buffer=[]
while lnum <= a:lastline
     if (foldclosed(lnum) == -1)
         let buffer += getline(lnum, lnum)
         let lnum += 1
     else
         let buffer += [ foldtextresult(lnum) ]
         let lnum = foldclosedend(lnum) + 1
     endif
endwhile
top new
set bt=nofile
call append(".",buffer)
0d_
endfu

com! -range=% CopyFolds :<line1>,<line2>call CopyNonFolded()

" :CopyNonFolded }}}
"
" :ToggleNumber {{{
"
function! ToggleNumber()
    if(&relativenumber == 1)
        set norelativenumber
        set number
    else
        set relativenumber
    endif
endfunc

" :ToggleNumber }}}

" :PrependLogestLineLenght {{{
"
function! PrependLongestLineLength()
    let maxlength   = 0
    let linenumber  = 1
    while linenumber <= line("$")
        exe ":".linenumber
        let linelength  = virtcol("$")
        if maxlength < linelength
            let maxlength = linelength
            let numerodelinea = linenumber
        endif
        let linenumber  = linenumber+1
    endwhile
    exe ':0'
    exe 'normal O'
    exe 'normal 0C'.numerodelinea
    "exe 'normal 0C'.maxlength
endfunction

" :PrependLongestLineLenght }}}

" :VisualSelection {{{
"
function! VisualSelection(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"
    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")
    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif
    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

" :VisualSelection }}}

" :VSetSearch {{{
"
function! s:VSetSearch()
    let temp = @@
    norm! gvy
    let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
    let @@ = temp
endfunction

" :VSetSearch }}}

" :MyTabline {{{
"
function! MyTabLine()
    let s=''
    let t=tabpagenr() " The index of current page
    let i=1
    while i<=tabpagenr('$') " From the first page
        let buflist=tabpagebuflist(i)
        let winnr=tabpagewinnr(i)
        let s.=(i==t ? '%#TabLineSel#' : '%#TabLine#')
        let s.='%'.i.'T'
        let s.=' '
        let bufnr=buflist[winnr-1]
        let file=bufname(bufnr)
        let buftype = getbufvar(bufnr, 'buftype')
        let m=''
        if getbufvar(bufnr, '&modified')
            let m='[+]'
        endif
        if buftype=='nofile'
            if file=~'\/.'
                let file=substitute(file, '.*\/\ze.', '', '')
            endif
        else
            let file=fnamemodify(file, ':p:t')
        endif
        if file==''
            let file='[No Name]'
        endif
        let s.=m
        let s.=i.':'
        let s.=file
        let s.='['.winnr.']'
        let s.=' '
        let i=i+1
    endwhile
    let s.='%T%#TabLineFill#%='
    let s.=(tabpagenr('$')>1 ? '%999XX' : 'X')
    return s
endfunction

" :MyTabline }}}

" :ShowFileFormatFlag {{{
"
function! ShowFileFormatFlag(var)
    if ( a:var == 'unix' )
        return '[unix]'
    elseif ( a:var == 'dos' )
        return '[dos]'
    else
        return '[mac]'
    endif
endfunction

" :ShowFileFormatFlag }}}

" :TabMessage {{{
"
function! TabMessage(cmd)
    " this function will pipe the out of a cmd into a new tab. or you can modi
    " to use a new split window instead
    " example:
    "   :TabMessage setglobal
    redir => message
    silent execute a:cmd
    redir END
    if empty(message)
        echoerr "no output"
    else
        " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
        new
        setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
        silent put=message
    endif
endfunction
command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

" :TabMessage }}}

" :OutputSplitWindow {{{
"
function! OutputSplitWindow(...)
    " this function output the result of the Ex command into a split scratch buffer
    " example:
    "   :Output echo strftime("%H:%M")
    " iab idate <c-r>=strftime("%Y-%m-%d")<CR>
    " iab itime <c-r>=strftime("%H:%M")<CR>
    " iab ifile <c-r>=expand("%:t")<CR>
    let cmd = join(a:000, ' ')
    let temp_reg = @"
    redir @"
    silent! execute cmd
    redir END
    let output = copy(@")
    let @" = temp_reg
    if empty(output)
        echoerr "no output"
    else
        new
        setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted
        put! =output
    endif
endfunction
command! -nargs=+ -complete=command Output call OutputSplitWindow(<f-args>)

" :OutputSplitWindow }}}

" :CreateTags {{{
"
function! CreateTags()
    let curNodePath = g:NERDTreeFileNode.GetSelected().path.str()
    exec ':!ctags -R --languages=php -f ' . curNodePath . '/tags ' . curNodePath
endfunction

" :CreateTags }}}

" :QuickfixFilenames {{{
"
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

" :QuickfixFilenames }}}

" :CopyMatches and :CopyLines {{{
"
" :GoScratch {{{
" Plugin to copy matches (search hits which may be multiline).
" Version 2012-05-03 from http://vim.wikia.com/wiki/VimTip478
"
" :CopyMatches      copy matches to clipboard (each match has newline added)
" :CopyMatches x    copy matches to register x
" :CopyMatches X    append matches to register x
" :CopyMatches -    display matches in a scratch buffer (does not copy)
" :CopyMatches pat  (after any of above options) use 'pat' as search pattern
" :CopyMatches!     (with any of above options) insert line numbers
" Same options work with the :CopyLines command (which copies whole lines).

" Jump to first scratch window visible in current tab, or create it.
" This is useful to accumulate results from successive operations.
" Global function that can be called from other scripts.
function! GoScratch()
  let done = 0
  for i in range(1, winnr('$'))
    execute i . 'wincmd w'
    if &buftype == 'nofile'
      let done = 1
      break
    endif
  endfor
  if !done
    new
    setlocal buftype=nofile bufhidden=hide noswapfile
  endif
endfunction
" :GoScratch }}}

" :Matcher {{{
" Append match, with line number as prefix if wanted.
function! s:Matcher(hits, match, linenums, subline)
  if !empty(a:match)
    let prefix = a:linenums ? printf('%3d  ', a:subline) : ''
    call add(a:hits, prefix . a:match)
  endif
  return a:match
endfunction
" :Matcher }}}

" :MatchLineNums {{{
" Append line numbers for lines in match to given list.
function! s:MatchLineNums(numlist, match)
  let newlinecount = len(substitute(a:match, '\n\@!.', '', 'g'))
  if a:match =~ "\n$"
    let newlinecount -= 1  " do not copy next line after newline
  endif
  call extend(a:numlist, range(line('.'), line('.') + newlinecount))
  return a:match
endfunction
" :MatchLineNums }}}

" :GetMatches {{{
" Return list of matches for given pattern in given range.
" If 'wholelines' is 1, whole lines containing a match are returned.
" This works with multiline matches.
" Work on a copy of buffer so unforeseen problems don't change it.
" Global function that can be called from other scripts.
function! GetMatches(line1, line2, pattern, wholelines, linenums)
  let savelz = &lazyredraw
  set lazyredraw
  let lines = getline(1, line('$'))
  new
  setlocal buftype=nofile bufhidden=delete noswapfile
  silent put =lines
  1d
  let hits = []
  let sub = a:line1 . ',' . a:line2 . 's/' . escape(a:pattern, '/')
  if a:wholelines
    let numlist = []  " numbers of lines containing a match
    let rep = '/\=s:MatchLineNums(numlist, submatch(0))/e'
  else
    let rep = '/\=s:Matcher(hits, submatch(0), a:linenums, line("."))/e'
  endif
  silent execute sub . rep . (&gdefault ? '' : 'g')
  close
  if a:wholelines
    let last = 0  " number of last copied line, to skip duplicates
    for lnum in numlist
      if lnum > last
        let last = lnum
        let prefix = a:linenums ? printf('%3d  ', lnum) : ''
        call add(hits, prefix . getline(lnum))
      endif
    endfor
  endif
  let &lazyredraw = savelz
  return hits
endfunction
" :GetMatches }}}

" :CopyMatches {{{
" Copy search matches to a register or a scratch buffer.
" If 'wholelines' is 1, whole lines containing a match are returned.
" Works with multiline matches. Works with a range (default is whole file).
" Search pattern is given in argument, or is the last-used search pattern.
function! s:CopyMatches(bang, line1, line2, args, wholelines)
  let l = matchlist(a:args, '^\%(\([a-zA-Z"*+-]\)\%($\|\s\+\)\)\?\(.*\)')
  let reg = empty(l[1]) ? '+' : l[1]
  let pattern = empty(l[2]) ? @/ : l[2]
  let hits = GetMatches(a:line1, a:line2, pattern, a:wholelines, a:bang)
  let msg = 'No non-empty matches'
  if !empty(hits)
    if reg == '-'
      call GoScratch()
      normal! G0m'
      silent put =hits
      " Jump to first line of hits and scroll to middle.
      ''+1normal! zz
    else
      execute 'let @' . reg . ' = join(hits, "\n") . "\n"'
    endif
    let msg = 'Number of matches: ' . len(hits)
  endif
  redraw  " so message is seen
  echo msg
endfunction
command! -bang -nargs=? -range=% CopyMatches call s:CopyMatches(<bang>0, <line1>, <line2>, <q-args>, 0)
command! -bang -nargs=? -range=% CopyLines call s:CopyMatches(<bang>0, <line1>, <line2>, <q-args>, 1)
" :CopyMatches }}}

" :CopyMatches and :CopyLines }}}

" :ResizeCmdHeight {{{
"
function! ResizeCmdHeight()
    if &columns > 120
        set cmdheight=2
    else
        set cmdheight=1
    endif
endfunction
call ResizeCmdHeight()

augroup ResizeCmdOnVimResizedx
    autocmd!
    autocmd VimResized * call ResizeCmdHeight()
augroup END

" :ResizeCmdHeight }}}

" :ClearRegisters {{{
"
function! s:ClearRegisters()
    let regs='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-="*+'
    let i=0
    while (i<strlen(regs))
        exec 'let @'.regs[i].'=""'
        let i=i+1
    endwhile
endfunction

command! ClearRegisters call s:ClearRegisters()

" :ClearRegisters }}}

" :align {{{
"
" Automatically call Tabular to align on | for Cucumber tables.
function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

" :align }}}

" :ReverseLines {{{
"
" Reverses all the lines in the file (top to bottom)
function! s:ReverseLines()
  :g/^/m0
endfunction
" }}}

" :RemoveM {{{
"
" Removes the ^M character from the end of every line
"    DOS     every line ends in CR and LF
"    UNIX    every line ends in LF only
"    with vim
"        :%s/<ctrl-v><ctrl-m>//g
"        :set ff=unix
"
function! s:RemoveM()
  :%s/$//gic
endfunction
" }}}

" :ReplaceM {{{
"
" Replaces the ^M character with a carriage return native to the system
"    DOS     every line ends in CR and LF
"    UNIX    every line ends in LF only
"    with vim
"        :%s/<ctrl-v><ctrl-m>//g
"        :set ff=unix
"
function! s:ReplaceM()
  :%s//\r/gic
endfunction
" }}}

" :RemoveWhiteSpace {{{
"
" Removes superfluous white space from the end of a line
function! s:RemoveWhiteSpace()
  :%s/\s*$//g
  :'^
"`.
endfunction
" }}}

" :VexToggle {{{

" File explorer with \ [TAB] or \ `
"function! VexToggle(dir)
"  if exists("t:vex_buf_nr")
"    call VexClose()
"  else
"    call VexOpen(a:dir)
"  endif
"endf
"
"function! VexOpen(dir)
"  let g:netrw_browse_split=4    " open files in previous window
"  let vex_width = 35
"
"  execute "Vexplore " . a:dir
"  let t:vex_buf_nr = bufnr("%")
"  wincmd H
"
"  call VexSize(vex_width)
"endf
"noremap <Leader><Tab> :call VexToggle(getcwd())<CR>
"noremap <Leader>` :call VexToggle("")<CR>
"
"function! VexClose()
"  let cur_win_nr = winnr()
"  let target_nr = ( cur_win_nr == 1 ? winnr("#") : cur_win_nr )
"
"  1wincmd w
"  close
"  unlet t:vex_buf_nr
"
"  execute (target_nr - 1) . "wincmd w"
"  call NormalizeWidths()
"endf
"
"function! VexSize(vex_width)
"  execute "vertical resize" . a:vex_width
"  set winfixwidth
"  call NormalizeWidths()
"endf
"
"function! NormalizeWidths()
"  let eadir_pref = &eadirection
"  set eadirection=hor
"  set equalalways! equalalways!
"  let &eadirection = eadir_pref
"endf
"augroup NetrwGroup
"  autocmd! BufEnter * call NormalizeWidths()
"augroup END
"
"let g:netrw_liststyle=0         " thin (change to 3 for tree)
"let g:netrw_banner=0            " no banner
"let g:netrw_altv=1              " open files on right
"let g:netrw_preview=1           " open previews vertically
"
"" Change directory to the current buffer when opening files.
"set autochdir

" :VexToggle }}}

" vimrc.local Functions }}}

" Help {{{

""""""" 000 {{{
"
"
""""""" 000 }}}

""""""" compare files {{{
" open both files in a split
"       :windo diffthis   'to start the comparition'
"       ]c or [c          'to junp into differences'
"       :diffget          'to get the diff'
"       :diffput          'to put the diff'
"       :windo diffoff    'to stop the comparition'
"
" or use the cmd in Terminal
"       $ vimdiff file1 file2
""""""" compare files }}}

""""""" converting files {{{
"    DOS     every line ends in CR LF
"    UNIX    every line ends in LF only
"    Convert a bunch of files Unix and Dos mix
"    dos/unix to UNIX
"        :args *.c *.h               " specify the files
"        :argdo set ff=unix|update   "for each arg, set unix ff and update
"        :bufdo! set ff=unix|w       "only all the open buffers
"
"    Convert Unix to Dos
"    in vimrc.local we have set
"        set ffs=unix,dos    " in a linux system
"        set ffs=dos,unix    " in a windows system
"    to convert a file use:
"        :e ++ff=unix
"        :update
"        :set local ff=unix
"        :w
"
"    Convert mixed files
"    dos/unix to UNIX
"        :set hidden         " allow modify buffers
"        :set ffs=dos
"        :args *.c *.h
"        :argdo set ff=unix|w
"    dos/unix to DOS
"        :set ffs=dos
"        :args *.c *.h
"        :argdo w
""""""" converting files }}}

""""""" copy/move lines {{{
" copy all lines matching the pattern to the EOF or BOF
"           :g/pattern/t$   --> EOF
"           :10,15t$        --> EOF lines 10 to 15
"           :g/pattern/t0   --> BOF
"           :10,15t0        --> BOF lines 10 to 15
"
" move all lines matching the pattern to the EOF
"           :g/pattern/m$
""""""" copy/move lines }}}

""""""" ctrlspace {{{
"   0. we open a set of files using :e or NertTree. All of them will be in one tab
"   1. or we use "TAB" to enter cmd mode of CtrlSpace and press "E" to display NerdTree, them press "t,T,o" to open a file and "q" to quit
"       t new tab
"       T new tab silenctly
"       o same window
"       q quit NerdTree
"   2. we can press l=tablist h=filelist o=bufflist b=bookmarks
"   3. we are back to cmd CtrlSpace we can use "h,l,o,b"
"   4. we can select the file from the list and press "> or <" to open that file in a new "TAB"
"   5. so we press "l" to display the tablist
"   6. we press "=" to change the name of the "TAB"
"   7. we do the same for the other tabs, then we we have all the names we want we press "h"
"   8. we can press "f,c,d" to forget, close or delete file from the list.
"   9. we can use "w,W" to open a workspace

"   a. :CtrlSpaceSaveWorkspace wsname
"   b. :CtrlSpaceLoadWorkspace wsname
"   c. :CtrlSpaceNewWorkspace
"
"   "b/B" Bookmark List
"     "a" to add a bookmark
"     "e" to edit the target dir
"     "=" renamed it
"
"   "o/O" Buffer List
"     "i" jumping to a dir of given buff
"     "I" jumping back
"
""""""" ctrlspace }}}

""""""" getting the ascii / hex code of the character under the cursor {{{
" let dec = char2nr(matchstr(getline('.'), '\%' . col('.') . 'c.'))
""""""" getting the ascii / hex code of the character under the cursor }}}

""""""" history {{{
"    q/      "search hist window (exit CTRL-C)
"    q:      "commandline history window (exit CTRL-C)
"    :<C-F>  "history window (exit CTRL-C)
"    :his        "disp history cmds
"    :his c      "commandline history
"    :his s      "search history
""""""" history }}}

""""""" key-notation {{{
"notation        meaning
"-----------|--------------------------------
"...
"<S-...>         shift-key
"<C-...>         control-key
"<M-...>         alt-key or meta-key
"<A-...>         alt-key same as <M-...>
"<D-...>         command-key (Macintosh only)
""""""" key-notation }}}

""""""" multiple_cursors {{{
" Vim Multiple Cursors
" Ctrl-N - start and select word under cursor for multicursor
"   Ctrl-N  - for next
"   Ctrl-X  - to skip
"   Ctrl-P  - remove current virtual cursor and go back to previous
"   Ctrl-Alt-A   - start multicursor and select all matches
"
"  c - change text
"  s - change
"  I - insert at start of a range
"  A - insert at end of a range
"  v - to use normal mode cmds
""""""" multiple_cursors }}}

""""""" Others {{{
" just view duplicates
"       /^\(.*\)\(\r\?\n\1\)\+$
"
" compress multiple occurrence of blank lines into a single blank line
"       :v/./,/./-j
"
" reverse a file
"           :g/^/m0
"
" maps <F5> to append a TAB and the local time to the curr line
"           nnoremap <F5> m'A<C-R>="\t".strftime('%Y-%m-%d %H:%M')<CR><Esc>``
"
" counting words in a file
"       :! wc %
"
" show or delete marks or clear marks
"       :marks
"       :delm!
""""""" Others }}}

""""""" read only file {{{
"       :w !sudo tee %
"       :w !sudo tee % > /dev/null
" asigned to a cmd
"       :w!!
"       :Sudo
" for when forgot to use sudo vim
"cmap w!! %!sudo tee > /dev/null %
"cnoremap w!! %!sudo tee > /dev/null %
"command! Sudo :execute ':silent w !sudo tee % > /dev/null' | :edit!
""""""" read only file }}}

""""""" remove/replace copy {{{
" remove tabs, spaces
"    :%s/{TAB}*$//               - strips blanks at end of line
"    :%s/ *$/                    - del blank spaces at the end of the line, we can use tab to remove tabs
"    :%s/^ */                    - del blank spaces at the beginning of the line
"
" remove any empty line or lines with only whitespace:
"           :g/^\s*$/d
"
" remove all lines that start with double quotes or spaces and double quotes '"'
"           :g/^\s*"/d
"
" remove all lines except those that start with double quotes or spaces and double quotes '"'
"           :g!/^\s*"/d  or  :v/^\s*"/d
"
" remove all lines that start with pound or number symbol or spaces and number symbol '#'
"           :g/^\s*#/d
"           :g/^\s*#/p  --> just print
"
" replace in a visual range, all the TAB's with spaces
"           :'<,'>s/^I/    /
"           :'<,'>!expand -t4            --> expand
"           :s/{ctrl-v}[TAB]/[TAB][TAB]/ --> if we have one tab we change it for two tabs
"           :'<,'>s/^I/^I^I^I/           --> replace a TAB with three TAB's
""""""" remove/replace copy }}}

""""""" save command history in a vim register {{{
"    :redir @a>
"        :history : -5,
"    :redir END
"then paste with
"    "ap
""""""" save command history in a vim register }}}

""""""" search/replace/delete {{{
"Delete HTML tags, leave text (non-greedy):
"  :%s#<[^>]\+>##g
"
"Delete HTML tags possible multi-line (non-greedy):
"  :%s#<\_.\{-1,}>##g
"
"Delete possibly multi-line comments
"  :%s/<!--\_.\{-}-->//
"
"Insert something at the BOL or EOL like <li> </li>:
"removing trailing space:
"  '<,'>s/\s*$/\<\/li\>/g
"leave trailing space:
"  '<,'>s/^/\<li\>/g
"  '<,'>s/$/\<\/li\>/g
"
""""""" search/replace/delete }}}

""""""" set statusline {{{
" no color:
" set statusline=%-3.3n\ %<%F%h%m%r%w\ \ \ \ \ %{strlen(&ft)?&ft:'none'}%=[%{strlen(&ft)?&ft:'none'},%{strlen(&fenc)?&fenc:&enc},%{&fileformat}]\ \ ⭡:\ %7l/%L\ %4v\ \ \ [Dec=\%03.3b]\ [Hx=\%02.2B]\ [U\+%04B]
" with color:
set statusline=%1*%-3.3n\ %4*%<%f%*%6*%h%m%r%w%1*\ \ \ \ \ %7*%{strlen(&ft)?&ft:'none'}%1*%=%*%3*\ [%5*%{strlen(&ft)?&ft:'none'},%{strlen(&fenc)?&fenc:&enc},%{&fileformat}%3*]\ \ %1*⭡:\ %7l%*%2*/%L%*%1*\ %4v\ \ \ %*%2*[Dec=\%03.3b]\ [Hx=\%02.2B]\ [U\+%04B]\ %*
"set statusline=%1*%-3.3n\ %4*%<%f%*%6*%h%m%r%w%1*\ %{exists('*CapsLockStatusline')?CapsLockStatusline():''}%=%-16(\ %l,%c-%v\ %)%P \ \ \ \ %7*%{strlen(&ft)?&ft:'none'}%1*%=%*%3*\ [%5*%{strlen(&ft)?&ft:'none'},%{strlen(&fenc)?&fenc:&enc},%{&fileformat}%3*]\ \ %1*⭡:\ %7l%*%2*/%L%*%1*\ %4v\ \ \ %*%2*[Dec=\%03.3b]\ [Hx=\%02.2B]\ [U\+%04B]\ %*
""""""" set statusline }}}

""""""" solarized colours {{{
" #004a5d
" #112125
" #002b36 //Base03
" #073642 //Base02
" #586e75 //Base01
" #657b83 //Base00
" #839496 //Base0
" #93a1a1 //Base1
" #eee8d5 //Base2
" #fdf6e3 //Base3
"
" #b58900 //yellow
" #cb4b16 //orange
" #dc322f //red
" #d33682 //magenta
" #6c71c4 //violet
" #268bd2 //blue
" #2aa198 //cyan
" #859900 //green
"
" highlight User1 guifg = #ffffff guibg = #dc322f
""""""" solarized colours }}}

""""""" sort {{{
" sort line 4 to 7
"       :4,7! sort -u
"
" or line 4 through end of file:
"       :4,$! sort -u
"
" and when a visual selection is active, that will automatically be the range used:
"       :! sort -u
""""""" sort }}}

""""""" spelling and syntax correction {{{
" toggle spelling"
"       :set spell! or <F3>
"       ]s -->  'find next spell error"
"       [s <--  'find prev spell error
"       z=      'using dictionary to find right or correct spell"
"       zg      'add to dictionary"
"       zw      'add to dictionary wrong"
"       zuw     'remove dic/wrong"
"       zug     'remove dic"
"       :runtime spell/cleanadd.vim         'to clean the dictionary"
""""""" spelling and syntax correction  }}}

""""""" tabularize {{{
"     :'<,'>Tabularize /:\zs
"       tells tab to use the char after the symbol indicated in the tabularize
"       aligment, in this case after ":", in some cases will be a <space>.
" other examples:
"     :'<,'>Tabularize /\t            ---> for a list with TAB's
"     :'<,'>Tabularize /\S\+;         ---> 1 or many non whitespaces, also followed by a semicolon
"     :'<,'>Tabularize /[a-z]*,/l0l1  ---> any string in lowercase with a comma
"     :"<,'>Tabularize /=/l0r1        ---> left align with 0 space in the left and 1 space in the right padding
"     :"<,'>Tabularize /=/r1c1l0      ---> put the delimeter in the middle
" leader plus cmd
"     ,a&    "tabularize
"     ,a,    "tabularize
"     ,a:    "tabularize
"     ,a::   "tabularize atom
"     ,a|    "tabularize
"     ,a=    "tabularize
""""""" tabularize }}}

""""""" troubleshooting .vimrc {{{
" load vim without any config file, to debut your .vimrc
"   $ vim -u NONE -U NONE -N -i NONE
"         -u NONE = no .vimrc
"         -U NONE = no .gvimrc
"         -i NONE = not reading the .viminfo file
" "         -N = nocompatible mode
"   $ vim -u NONE -U NONE -N
"
" hot to open another .vimrc
"   $ vim -u ~/.vimrc --noplugin -N -i NONE
"
" the last resource is to use the cmd :finish
"   :finish in the middle of the .vimrc file and open to see
"   :finish cmd to another part and keep going
"
" how to reset the options
"     :set option-name&
"     :set option-name&vi
"     :set option-name&vim
" either of this will work depending of your settings.
" or to set all the options to its default value use:
"     :set all&
"     :set all&vi
""""""" troubleshooting .vimrc }}}

""""""" vim help navigation {{{
" possition curson under the subject and press
"        Ctrl-]
"    to go back press
"        Ctrl-t or Ctrl-o
""""""" vim help navigation }}}

""""""" write/append/insert/add lines {{{
" write/append lines to external file
"           :1,10w otherfile.txt | 1,5w >> otherfile.txt
"
" add Error to each line selected
"           :'a,'b s!^!Error !
"           :%s!^!Error!  or  '<,'> s/^/Error/
"           vmap \c :s!^!//!<CR>
"           vmap \u :s!^//!!<CR>
"
" list in a windows the search result
"       :vimgrep /Error/ %
"       :cope
"       :vimgrepadd /otherpattern/ %
"
" insert the execution of a cmd in vim
"           :r!<cmd>
" include the list of files of a dir
"       :r !ls -l /home/ronvox/Downloads
"
" in linux and vim will find all files that were mod in the last 8 days
"           :R find -mtime -8 | xargs grep vim
"
" using a text-mode browser "w3m" grab all the text of a web page
"       :r ! w3m http://en.wikipedia.org/wiki/Vi -dump
"
" add mytext to the end of the line that matches the pattern
"       :g/^pattern/s/$/mytext
""""""" write/append/insert/add lines }}}

" Help }}}
